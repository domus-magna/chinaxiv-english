name: Pipeline Orchestrator
# NOTE: Experimental manual trigger while we evaluate GitHub workflow_run orchestration.

on:
  workflow_dispatch:
    inputs:
      stages:
        description: 'Pipeline stages to run (comma-separated: preflight,harvest,ocr,translate,qa,render)'
        required: false
        default: 'preflight,harvest,ocr,translate,qa,render'
      batch_size:
        description: 'Papers per batch'
        required: false
        default: '100'
      workers:
        description: 'Parallel workers per stage'
        required: false
        default: '20'
      matrix_size:
        description: 'Matrix parallelism (number of parallel jobs)'
        required: false
        default: '3'

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    outputs:
      stages: ${{ steps.parse-stages.outputs.stages }}
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse stages
        id: parse-stages
        run: |
          STAGES="${{ github.event.inputs.stages || 'preflight,harvest,ocr,translate,qa,render' }}"
          echo "stages=$STAGES" >> $GITHUB_OUTPUT
          echo "Running stages: $STAGES"

      - name: Trigger and wait for preflight gate
        if: contains(steps.parse-stages.outputs.stages, 'preflight')
        uses: actions/github-script@v7
        with:
          script: |
            const workflowFile = 'preflight.yml';
            const ref = context.ref;
            const headBranch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : undefined;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const findRun = async (startedAtIso) => {
              const maxAttempts = 24; // wait up to 2 minutes for the run to appear
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowFile,
                  event: 'workflow_dispatch',
                  per_page: 25,
                };
                if (headBranch) {
                  params.branch = headBranch;
                }
                const { data } = await github.rest.actions.listWorkflowRuns(params);
                const targetRun = data.workflow_runs.find((run) => new Date(run.created_at) >= new Date(startedAtIso));
                if (targetRun) {
                  core.info(`Found ${workflowFile} run ${targetRun.id} on attempt ${attempt}.`);
                  return targetRun;
                }
                core.info(`Waiting for ${workflowFile} run to start (attempt ${attempt}/${maxAttempts})...`);
                await sleep(5000);
              }
              throw new Error(`Timed out waiting for ${workflowFile} run to start.`);
            };

            const waitForCompletion = async (runId) => {
              const maxAttempts = 160; // ~40 minutes at 15s intervals
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: run } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                });
                if (run.status === 'completed') {
                  core.info(`${workflowFile} concluded with status ${run.conclusion}.`);
                  if (run.conclusion !== 'success') {
                    throw new Error(`${workflowFile} failed with conclusion ${run.conclusion}.`);
                  }
                  return;
                }
                core.info(`${workflowFile} run ${runId} status ${run.status}; waiting...`);
                await sleep(15000);
              }
              throw new Error(`${workflowFile} did not complete before timeout.`);
            };

            const startedAtIso = new Date(Date.now() - 1000).toISOString();
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowFile,
              ref,
            });
            core.info(`Triggered ${workflowFile} on ref ${ref}.`);
            const run = await findRun(startedAtIso);
            await waitForCompletion(run.id);

      - name: Trigger and wait for harvest gate
        if: contains(steps.parse-stages.outputs.stages, 'harvest')
        uses: actions/github-script@v7
        with:
          script: |
            const workflowFile = 'harvest-gate.yml';
            const ref = context.ref;
            const headBranch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : undefined;
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const findRun = async (startedAtIso) => {
              const maxAttempts = 24;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowFile,
                  event: 'workflow_dispatch',
                  per_page: 25,
                };
                if (headBranch) {
                  params.branch = headBranch;
                }
                const { data } = await github.rest.actions.listWorkflowRuns(params);
                const targetRun = data.workflow_runs.find((run) => new Date(run.created_at) >= new Date(startedAtIso));
                if (targetRun) {
                  core.info(`Found ${workflowFile} run ${targetRun.id}.`);
                  return targetRun;
                }
                core.info(`Waiting for ${workflowFile} run to start (attempt ${attempt}/${maxAttempts})...`);
                await sleep(5000);
              }
              throw new Error(`Timed out waiting for ${workflowFile} run to start.`);
            };

            const waitForCompletion = async (runId) => {
              const maxAttempts = 160;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: run } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                });
                if (run.status === 'completed') {
                  core.info(`${workflowFile} finished with ${run.conclusion}.`);
                  if (run.conclusion !== 'success') {
                    throw new Error(`${workflowFile} failed with conclusion ${run.conclusion}.`);
                  }
                  return;
                }
                core.info(`${workflowFile} run ${runId} status ${run.status}; waiting...`);
                await sleep(15000);
              }
              throw new Error(`${workflowFile} did not complete before timeout.`);
            };

            const startedAtIso = new Date(Date.now() - 1000).toISOString();
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowFile,
              ref,
            });
            core.info(`Triggered ${workflowFile} on ref ${ref}.`);
            const run = await findRun(startedAtIso);
            await waitForCompletion(run.id);

      - name: Trigger and wait for OCR gate
        if: contains(steps.parse-stages.outputs.stages, 'ocr')
        uses: actions/github-script@v7
        with:
          script: |
            const workflowFile = 'ocr-gate.yml';
            const ref = context.ref;
            const headBranch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : undefined;
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const findRun = async (startedAtIso) => {
              const maxAttempts = 24;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowFile,
                  event: 'workflow_dispatch',
                  per_page: 25,
                };
                if (headBranch) {
                  params.branch = headBranch;
                }
                const { data } = await github.rest.actions.listWorkflowRuns(params);
                const targetRun = data.workflow_runs.find((run) => new Date(run.created_at) >= new Date(startedAtIso));
                if (targetRun) {
                  core.info(`Found ${workflowFile} run ${targetRun.id}.`);
                  return targetRun;
                }
                core.info(`Waiting for ${workflowFile} run to start (attempt ${attempt}/${maxAttempts})...`);
                await sleep(5000);
              }
              throw new Error(`Timed out waiting for ${workflowFile} run to start.`);
            };

            const waitForCompletion = async (runId) => {
              const maxAttempts = 160;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: run } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                });
                if (run.status === 'completed') {
                  core.info(`${workflowFile} finished with ${run.conclusion}.`);
                  if (run.conclusion !== 'success') {
                    throw new Error(`${workflowFile} failed with conclusion ${run.conclusion}.`);
                  }
                  return;
                }
                core.info(`${workflowFile} run ${runId} status ${run.status}; waiting...`);
                await sleep(15000);
              }
              throw new Error(`${workflowFile} did not complete before timeout.`);
            };

            const startedAtIso = new Date(Date.now() - 1000).toISOString();
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowFile,
              ref,
            });
            core.info(`Triggered ${workflowFile} on ref ${ref}.`);
            const run = await findRun(startedAtIso);
            await waitForCompletion(run.id);

      - name: Trigger and wait for translation gate matrix
        if: contains(steps.parse-stages.outputs.stages, 'translate')
        uses: actions/github-script@v7
        with:
          script: |
            const workflowFile = 'translation-gate.yml';
            const ref = context.ref;
            const headBranch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : undefined;
            const matrixSize = parseInt('${{ github.event.inputs.matrix_size || '3' }}', 10);
            const batchSize = '${{ github.event.inputs.batch_size || '100' }}';
            const workers = '${{ github.event.inputs.workers || '20' }}';
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const findRun = async (startedAtIso, seenIds) => {
              const maxAttempts = 24;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowFile,
                  event: 'workflow_dispatch',
                  per_page: 50,
                };
                if (headBranch) {
                  params.branch = headBranch;
                }
                const { data } = await github.rest.actions.listWorkflowRuns(params);
                const targetRun = data.workflow_runs.find((run) => new Date(run.created_at) >= new Date(startedAtIso) && !seenIds.has(run.id));
                if (targetRun) {
                  core.info(`Identified ${workflowFile} run ${targetRun.id}.`);
                  return targetRun;
                }
                core.info(`Waiting for ${workflowFile} matrix run to start (attempt ${attempt}/${maxAttempts})...`);
                await sleep(5000);
              }
              throw new Error(`Timed out waiting for ${workflowFile} matrix run to start.`);
            };

            const waitForCompletion = async (runId) => {
              const maxAttempts = 240; // allow longer for parallel batches (~60 minutes)
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: run } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                });
                if (run.status === 'completed') {
                  core.info(`${workflowFile} run ${runId} concluded with ${run.conclusion}.`);
                  if (run.conclusion !== 'success') {
                    throw new Error(`${workflowFile} run ${runId} failed with conclusion ${run.conclusion}.`);
                  }
                  return;
                }
                core.info(`${workflowFile} run ${runId} status ${run.status}; waiting...`);
                await sleep(15000);
              }
              throw new Error(`${workflowFile} run ${runId} did not complete before timeout.`);
            };

            const seenIds = new Set();
            const runIds = [];
            for (let i = 0; i < matrixSize; i++) {
              const startedAtIso = new Date(Date.now() - 1000).toISOString();
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowFile,
                ref,
                inputs: {
                  batch_size: batchSize,
                  workers: workers,
                  matrix_index: i.toString(),
                },
              });
              core.info(`Triggered ${workflowFile} matrix job ${i} on ref ${ref}.`);
              const run = await findRun(startedAtIso, seenIds);
              seenIds.add(run.id);
              runIds.push(run.id);
            }

            for (const runId of runIds) {
              await waitForCompletion(runId);
            }

      - name: Trigger and wait for QA gate
        if: contains(steps.parse-stages.outputs.stages, 'qa')
        uses: actions/github-script@v7
        with:
          script: |
            const workflowFile = 'translation-gate.yml';
            const ref = context.ref;
            const headBranch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : undefined;
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const findRun = async (startedAtIso) => {
              const maxAttempts = 24;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowFile,
                  event: 'workflow_dispatch',
                  per_page: 25,
                };
                if (headBranch) {
                  params.branch = headBranch;
                }
                const { data } = await github.rest.actions.listWorkflowRuns(params);
                const targetRun = data.workflow_runs.find((run) => new Date(run.created_at) >= new Date(startedAtIso));
                if (targetRun) {
                  core.info(`Found ${workflowFile} QA run ${targetRun.id}.`);
                  return targetRun;
                }
                core.info(`Waiting for ${workflowFile} QA run to start (attempt ${attempt}/${maxAttempts})...`);
                await sleep(5000);
              }
              throw new Error(`Timed out waiting for ${workflowFile} QA run to start.`);
            };

            const waitForCompletion = async (runId) => {
              const maxAttempts = 160;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: run } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                });
                if (run.status === 'completed') {
                  core.info(`QA run ${runId} concluded with ${run.conclusion}.`);
                  if (run.conclusion !== 'success') {
                    throw new Error(`QA workflow failed with conclusion ${run.conclusion}.`);
                  }
                  return;
                }
                core.info(`QA run ${runId} status ${run.status}; waiting...`);
                await sleep(15000);
              }
              throw new Error(`QA workflow did not complete before timeout.`);
            };

            const startedAtIso = new Date(Date.now() - 1000).toISOString();
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowFile,
              ref,
            });
            core.info(`Triggered QA workflow ${workflowFile} on ref ${ref}.`);
            const run = await findRun(startedAtIso);
            await waitForCompletion(run.id);

      - name: Trigger and wait for render gate
        if: contains(steps.parse-stages.outputs.stages, 'render')
        uses: actions/github-script@v7
        with:
          script: |
            const workflowFile = 'render-gate.yml';
            const ref = context.ref;
            const headBranch = ref.startsWith('refs/heads/') ? ref.replace('refs/heads/', '') : undefined;
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            const findRun = async (startedAtIso) => {
              const maxAttempts = 24;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflowFile,
                  event: 'workflow_dispatch',
                  per_page: 25,
                };
                if (headBranch) {
                  params.branch = headBranch;
                }
                const { data } = await github.rest.actions.listWorkflowRuns(params);
                const targetRun = data.workflow_runs.find((run) => new Date(run.created_at) >= new Date(startedAtIso));
                if (targetRun) {
                  core.info(`Found render gate run ${targetRun.id}.`);
                  return targetRun;
                }
                core.info(`Waiting for render gate run to start (attempt ${attempt}/${maxAttempts})...`);
                await sleep(5000);
              }
              throw new Error(`Timed out waiting for render gate run to start.`);
            };

            const waitForCompletion = async (runId) => {
              const maxAttempts = 160;
              for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { data: run } = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId,
                });
                if (run.status === 'completed') {
                  core.info(`Render gate run ${runId} concluded with ${run.conclusion}.`);
                  if (run.conclusion !== 'success') {
                    throw new Error(`Render gate failed with conclusion ${run.conclusion}.`);
                  }
                  return;
                }
                core.info(`Render gate run ${runId} status ${run.status}; waiting...`);
                await sleep(15000);
              }
              throw new Error(`Render gate did not complete before timeout.`);
            };

            const startedAtIso = new Date(Date.now() - 1000).toISOString();
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowFile,
              ref,
            });
            core.info(`Triggered ${workflowFile} on ref ${ref}.`);
            const run = await findRun(startedAtIso);
            await waitForCompletion(run.id);

      - name: Generate pipeline report
        if: always()
        run: |
          echo "Pipeline orchestration complete"
          echo "Stages requested: ${{ steps.parse-stages.outputs.stages }}"
          echo "Matrix size: ${{ github.event.inputs.matrix_size || '3' }}"
          echo "Batch size: ${{ github.event.inputs.batch_size || '100' }}"
          echo "Workers: ${{ github.event.inputs.workers || '20' }}"
